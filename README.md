# Viveka_Tirtha_ML_Python

* **COMS Day 1 - Video Link:** https://tinyurl.com/mpmsxd83 (Python I/P, Operators, Condition Statements)
* **CMOS Day 2 - Video Link:** https://tinyurl.com/yc3u2juy (Python Loops and Logic Building)
* **CMOS Day 3 - Video Link:** https://tinyurl.com/m82nxt6v (Math Module and String Processing)
* **CMOS Day 4 - Video Link:** https://tinyurl.com/bdesmjak (Exception Handling)

**Class Sequence Order**<br>
* ClassWorkFile-1.ipynb / Code-Day-1.ipynb
* Exception Handling.ipynb
* ClassWorkFile-2.ipynb / Code-Day-2.ipynb
* OOP.ipynb
* Database-Day-3.ipynb
* NumPy.ipynb
* Pandas.ipynb
* AEC Data Visualization.ipynb

**Pressman E-Book Download Link:**<br>
https://www.mlsu.ac.in/econtents/16_EBOOK-7th_ed_software_engineering_a_practitioners_approach_by_roger_s._pressman_.pdf

**Python Download Link:**<br>
**Anaconda Download Link:** https://www.anaconda.com/products/distribution

**Online Python Editors:**<br>
https://onecompiler.com/<br>
https://www.onlinegdb.com/

**Python Study Material Links:**<br>
**Python for you and me:** https://pymbook.readthedocs.io/en/latest/<br>
**Python Practice Book:** https://anandology.com/python-practice-book/index.html<br>
**Learn Python Programming (programmiz.com):** https://www.programiz.com/python-programming<br>
**Learn Python Programming (data-flair):** https://data-flair.training/blogs/python-tutorial/

**MS-Office/O365 Reference Tutorial Links -**<br>
* **MS-Office 2007:** https://edu.gcfglobal.org/en/topics/office2007/
* **MS-Office 2010:** https://edu.gcfglobal.org/en/topics/office2010/
* **MS-Office 2013:** https://edu.gcfglobal.org/en/topics/office2013/
* **MS-Office 2016:** https://edu.gcfglobal.org/en/topics/office2016/
* **MS-Excel Formulas:** https://edu.gcfglobal.org/en/excelformulas/
* **50 Tips to Master Excel ebook:** https://drive.google.com/file/d/0ByEvd0vhZtF3Zm9tY09YNWpuUnM/view
<hr>

### Features of Python
Python is a popular high-level programming language that is used for various purposes such as web development, data analysis, artificial intelligence, scientific computing, and more. Some of the key features of Python include:

* **Easy to Learn and Use:** Python has a simple and easy-to-understand syntax that makes it easy for developers to write code quickly and efficiently. Its readability makes it an excellent choice for beginners who are just starting out in programming.

* **Open-Source:** Python is an open-source programming language, which means it is free to use, distribute, and modify. This makes it accessible to anyone who wants to use it, including individuals, businesses, and organizations.

* **Cross-Platform:** Python can run on a variety of operating systems, including Windows, Mac, and Linux. This makes it a versatile language that can be used on different platforms and devices.

* **Rich Library Support:** Python has a vast library of modules and packages that can be used for various purposes, such as data analysis, web development, machine learning, and more. These libraries make it easy for developers to write complex applications quickly and efficiently.

* **High-Level Language:** Python is a high-level language, which means it abstracts away much of the low-level details of programming, such as memory management and pointer manipulation. This allows developers to focus on solving problems and writing code, rather than worrying about the low-level details.

* **Dynamically Typed:** Python is a dynamically typed language, which means the data types of variables are determined at runtime. This makes it easy for developers to write code quickly, as they do not need to declare variable types in advance.

* **Object-Oriented:** Python is an object-oriented language, which means it uses classes and objects to represent real-world entities and concepts. This makes it easy for developers to write modular and reusable code.

* **Community Support:** Python has a large and active community of developers who contribute to the language and its libraries. This community support makes it easy for developers to find help and resources when needed.

<hr>

### Applications of Python
Python is a versatile programming language that can be used for various applications in different domains. Some of the common applications of Python are:

* **Web Development:** Python can be used to develop web applications using frameworks such as Django, Flask, Pyramid, and Bottle. These frameworks provide a simple and easy-to-use interface for developers to create web applications quickly.

* **Data Analysis and Visualization:** Python has various libraries such as NumPy, Pandas, Matplotlib, and Seaborn that provide powerful tools for data analysis and visualization. These libraries make it easy for developers to analyze and visualize large amounts of data.

* **Machine Learning and Artificial Intelligence:** Python is widely used in the field of machine learning and artificial intelligence. Libraries such as TensorFlow, Keras, Scikit-learn, and PyTorch provide powerful tools for building machine learning models.

* **Scientific Computing:** Python is used extensively in scientific computing due to its ability to handle complex mathematical calculations. Libraries such as SciPy and NumPy provide tools for numerical computing, scientific visualization, and signal processing.

* **Desktop Applications:** Python can be used to develop desktop applications using frameworks such as PyQt, wxPython, and PyGTK. These frameworks provide a simple and easy-to-use interface for building cross-platform desktop applications.

* **Game Development:** Python can be used to develop games using libraries such as Pygame and Panda3D. These libraries provide tools for creating 2D and 3D games.

* **Automation and Scripting:** Python can be used for automation and scripting tasks, such as web scraping, data processing, and system administration. Its simple and easy-to-use syntax makes it an excellent choice for scripting tasks.

Overall, Python's versatility and ease of use make it an excellent choice for a wide range of applications, from web development and data analysis to machine learning and scientific computing.

<hr>

### Python Datatypes
Python has several built-in datatypes, including:

* **Integer (int):** This datatype represents whole numbers, both positive and negative.

* **Float:** This datatype represents real numbers with decimal points.

* **Boolean (bool):** This datatype represents a binary value, either True or False.

* **String (str):** This datatype represents a sequence of characters, enclosed in single or double quotes.

* **List:** This datatype represents an ordered collection of items, enclosed in square brackets and separated by commas.

* **Tuple:** This datatype is similar to a list, but its values are enclosed in parentheses and cannot be modified once created.

* **Set:** This datatype represents an unordered collection of unique items, enclosed in curly braces.

* **Dictionary:** This datatype represents a collection of key-value pairs, enclosed in curly braces and separated by colons.

* **None:** This datatype represents the absence of a value and is often used to represent a null value or default value.

These datatypes can be used to store and manipulate data in Python programs. Python also allows for dynamic typing, meaning that variables can change datatypes during runtime.

<hr>

### Python Operators
Python operators are symbols that allow you to perform operations on one or more values or variables. Python provides various types of operators:

* **Arithmetic Operators:** Arithmetic operators are used to perform mathematical operations like addition, subtraction, multiplication, division, modulus, and exponentiation.

Examples:

<pre>
+   # addition
-   # subtraction
*   # multiplication
/   # division
%   # modulus
**  # exponentiation
//  # floor division
</pre>

* **Comparison Operators:** Comparison operators are used to compare two values and return True or False.

Examples:

<pre>
==  # equal to
!=  # not equal to
<   # less than
&gt;   # greater than
<=  # less than or equal to
>=  # greater than or equal to
</pre>

* **Logical Operators:** Logical operators are used to combine two or more conditions and return True or False.

Examples:

<pre>
and  # logical AND
or   # logical OR
not  # logical NOT
</pre>

* **Assignment Operators:** Assignment operators are used to assign values to variables.

Examples:

<pre>
=   # assign a value
+=  # add and assign
-=  # subtract and assign
*=  # multiply and assign
/=  # divide and assign
%=  # modulus and assign
**= # exponentiate and assign
//= # floor divide and assign
</pre>

* **Bitwise Operators:** Bitwise operators are used to perform bitwise operations on integers.

Examples:

<pre>
&   # bitwise AND
|   # bitwise OR
^   # bitwise XOR
~   # bitwise NOT
<<  # bitwise left shift
>>  # bitwise right shift
</pre>

* **Membership Operators:** Membership operators are used to test if a sequence is present in an object.

Examples:

<pre>
in    # test if a value is present in a sequence
not in # test if a value is not present in a sequence
</pre>

* **Identity Operators:** Identity operators are used to compare the memory location of two objects.

Examples:

<pre>
is    # test if two variables refer to the same object
is not # test if two variables do not refer to the same object
</pre>

<hr>

### Conditional Statements in Python
In Python, conditional statements are used to control the flow of execution based on certain conditions. The most common conditional statements are if, elif, and else.

The basic syntax of an if statement is as follows:

<pre>
if condition:
    statement(s)
</pre>

Here, condition is an expression that is evaluated to either True or False. If the condition is True, then the statement(s) inside the if block are executed. If the condition is False, then the statement(s) inside the if block are skipped.

For example:

<pre>
x = 5
if x &gt; 0:
    print("x is positive")
</pre>

This code will print "x is positive", since the condition x &gt; 0 is True.

The elif statement is used to add additional conditions to an if statement. The syntax is as follows:

<pre>
if condition1:
    statement(s)
elif condition2:
    statement(s)
elif condition3:
    statement(s)
else:
    statement(s)
</pre>

Here, elif stands for "else if". If the first if condition is False, then the elif conditions are evaluated in order. If a condition is True, then the corresponding statement(s) are executed and the rest of the elif conditions are skipped. If all elif conditions are False, then the else block (if present) is executed.

For example:

<pre>
x = 0
if x &gt; 0:
    print("x is positive")
elif x == 0:
    print("x is zero")
else:
    print("x is negative")
</pre>

This code will print "x is zero", since the first condition is False, the second condition is True, and the third condition is skipped.

It's also possible to use nested if statements to create more complex conditions. For example:

<pre>
x = 5
if x &gt; 0:
    if x &lt; 10:
        print("x is a single digit positive number")
    else:
        print("x is a positive number greater than or equal to 10")
else:
    print("x is not a positive number")
</pre>

This code will print "x is a single digit positive number", since both conditions are True.

<hr>

### Python Loops
In Python, loops are used to repeat a block of code multiple times. There are two main types of loops: for loops and while loops.

A for loop is used to iterate over a sequence (such as a list, tuple, or string) or any iterable object. The basic syntax of a for loop is as follows:

<pre>
for variable in sequence:
    statement(s)
</pre>

Here, sequence is a sequence or iterable object, and variable is a variable that takes on the value of each element in the sequence one at a time. The statement(s) inside the loop are executed for each value of variable in the sequence.

For example:

<pre>
my_list = [1, 2, 3, 4, 5]
for i in my_list:
    print(i)
</pre>

This code will print the values 1 through 5, since the variable i takes on the values of each element in my_list one at a time.

A while loop is used to repeat a block of code as long as a certain condition is True. The basic syntax of a while loop is as follows:

<pre>
while condition:
    statement(s)
</pre>

Here, condition is an expression that is evaluated to either True or False. The statement(s) inside the loop are executed as long as the condition is True.

For example:

<pre>
i = 0
while i &lt; 5:
    print(i)
    i += 1
</pre>

This code will print the values 0 through 4, since the loop will continue as long as i is less than 5.

Both for and while loops can be controlled using the break and continue statements. The break statement is used to exit the loop prematurely, while the continue statement is used to skip the current iteration of the loop and move on to the next one.

For example:

<pre>
my_list = [1, 2, 3, 4, 5]
for i in my_list:
    if i == 3:
        break
    print(i)
</pre>

This code will print the values 1 and 2, since the loop will exit when i is equal to 3.

<pre>
my_list = [1, 2, 3, 4, 5]
for i in my_list:
    if i == 3:
        continue
    print(i)
</pre>

This code will print the values 1, 2, 4, and 5, since the loop will skip the iteration when i is equal to 3.

<hr>

### User Defined Functions (UDFs) in Python
In Python, you can define your own functions to perform specific tasks. Functions are a way to group code that performs a specific task, which makes it easier to reuse the code and keep your programs organized.

The basic syntax for defining a function in Python is as follows:

<pre>
def function_name(parameters):
    statement(s)
    return value
</pre>

Here, function_name is the name of the function, and parameters is a comma-separated list of input parameters that the function takes. The statement(s) inside the function perform the task that the function is designed to do, and the return statement returns a value (if necessary).

For example, here is a function that takes two parameters and returns their sum:

<pre>
def add_numbers(x, y):
    result = x + y
    return result
</pre>

To call this function, you simply pass in the required parameters:

<pre>
sum = add_numbers(5, 10)
print(sum)
</pre>

This code will output 15, since the add_numbers function takes the parameters 5 and 10, adds them together, and returns the result.

Functions can also have optional parameters with default values. Here's an example:

<pre>
def greet(name, greeting="Hello"):
    print(greeting + ", " + name)
</pre>

In this case, the greeting parameter is optional and has a default value of "Hello". You can call the function with or without the greeting parameter:

<pre>
greet("Alice")
greet("Bob", "Hi")
</pre>

This code will output:

<pre>
Hello, Alice
Hi, Bob
</pre>

Functions can also have variable-length argument lists using *args and &ast;&ast;kwargs syntax. *args is used to pass a variable number of non-keyword arguments to the function, while &ast;&ast;kwargs is used to pass a variable number of keyword arguments to the function. Here's an example:

<pre>
def my_function(*args, **kwargs):
    print(args)
    print(kwargs)
</pre>

You can call this function with any number of arguments:

<pre>
my_function(1, 2, 3, name="Alice", age=30)
</pre>

This code will output:

<pre>
(1, 2, 3)
{'name': 'Alice', 'age': 30}
</pre>

This function takes three non-keyword arguments and two keyword arguments, and prints them out using the args and kwargs parameters.

<hr>

### What are the features of functional programming?
Functional programming is a programming paradigm that emphasizes the use of functions to solve problems. Here are some of the key features of functional programming:

* **Functions as First-Class Citizens:** In functional programming, functions are treated as first-class citizens (or also called first-class objects), which means they can be assigned to variables, passed as arguments to other functions, and returned as values from functions.

* **Immutable Data:** Functional programming languages discourage or prohibit the changing of state or mutable data. Instead, they emphasize the use of immutable data structures that don't change during the program execution.

* **Pure Functions:** Pure functions are functions that do not have any side effects and return the same output for the same input every time. Pure functions are free from any external dependencies or state changes, making them easier to test and reason about.

* **Higher-Order Functions:** Functional programming languages often have support for higher-order functions, which are functions that can take other functions as arguments or return functions as values. Higher-order functions can be used to create abstractions and solve problems in a more concise way.

* **Recursion:** Functional programming languages typically use recursion as a primary means of iteration. Instead of using loops to iterate through data, functions are called recursively with new input until a base case is reached.

* **Lazy Evaluation:** Lazy evaluation is a feature of some functional programming languages where expressions are only evaluated when needed, rather than eagerly evaluated at the time they are defined. This can lead to improved performance and more efficient use of resources.

* **Declarative Style:** Functional programming languages encourage a declarative programming style where programs are written as a series of expressions that describe what the program should do, rather than how to do it. This can make programs easier to read and understand.

### What are the features of lambda function in Python?
In Python programming, a lambda function is a small anonymous function that can have any number of arguments, but can only have one expression. The expression is evaluated and returned as the function result. Lambda functions are commonly used in combination with higher-order functions such as map(), filter(), and reduce().

Some of the properties of lambda functions in Python programming include:
* **Anonymous:** Lambda functions are anonymous, meaning they do not have a name like regular functions. They are defined using the keyword "lambda" followed by the arguments and the expression.
* **Single Expression:** A lambda function can only contain a single expression that is evaluated and returned as the function result. This means that it cannot contain multiple statements or control flow structures.
* **Concise:** Lambda functions are concise and can be defined in a single line of code. This makes them useful for defining simple functions on-the-fly.
* **Immutable:** Lambda functions are immutable, meaning they cannot be modified once defined. This means that you cannot change the behavior of a lambda function after it has been defined.
* **Higher-order Functions:** Lambda functions are often used in combination with higher-order functions such as map(), filter(), and reduce(). These functions take other functions as arguments and return new functions as results.
* **Memory-efficient:** Lambda functions are memory-efficient since they are defined on-the-fly and do not require a separate function definition. This can be useful when working with large data sets or when memory usage is a concern.
* **One-Liners:** Lambda functions are often used for simple, one-liner operations such as filtering, sorting, or mapping data.
* **Functional Programming:** Lambda functions are a key feature of functional programming in Python, allowing for higher-order functions and other functional programming techniques.
* **Variables:** Lambda functions can use variables from the enclosing scope, which can be useful in some cases. However, this can lead to unexpected behavior if not used carefully.

### How to use lambda functions in Python?
A lambda function is a small, anonymous function in Python that can be defined without a name. It is also called a lambda expression or a lambda abstraction.

The syntax for a lambda function is:<br>
**lambda arguments: expression**<br>
The arguments are the inputs to the function and the expression is the operation performed on the input. The lambda function returns the result of the expression.

Here's an example of a lambda function that adds two numbers:<br>
**add = lambda x, y: x + y**<br>
The add lambda function takes two arguments x and y, and returns their sum.

Lambda functions are often used as a quick and easy way to define simple functions that are only used once. For example, suppose you have a list of numbers and you want to sort them in descending order. You can use the built-in sorted function with a lambda function as the key parameter:<br>
**numbers = [5, 2, 8, 1, 3]<br>
sorted_numbers = sorted(numbers, key=lambda x: -x)<br>
print(sorted_numbers)  # prints [8, 5, 3, 2, 1]**<br>
In this example, the lambda function lambda x: -x is used as the key function for sorting the list in descending order. The lambda function takes one argument x and returns its negation, which effectively reverses the order of the numbers.

<hr>

### Exception handling in Python
In Python, exception handling is a way to deal with errors that may occur during the execution of a program. When an error occurs, an exception is raised. If this exception is not caught and handled, the program will terminate with an error message. However, by using exception handling, you can catch the exception and handle it in a way that allows the program to continue running.

URL for Python Exception Hierarchy: https://docs.python.org/3/library/exceptions.html<br>

To handle exceptions in Python, you use the try and except statements. The try statement encloses a block of code that may raise an exception. The except statement specifies how to handle the exception that is raised. Here's an example:


try:
    # code that may raise an exception
except ExceptionType:
    # code to handle the exception

In this example, ExceptionType is the type of exception that you want to catch. If an exception of this type is raised within the try block, the code in the except block will be executed. If no exception is raised, the code in the except block will be skipped.

You can also use multiple except statements to handle different types of exceptions. For example:

<pre>
try:
    # code that may raise an exception
except ExceptionType1:
    # code to handle the first type of exception
except ExceptionType2:
    # code to handle the second type of exception
</pre>

In this example, if an exception of ExceptionType1 is raised, the first except block will be executed. If an exception of ExceptionType2 is raised, the second except block will be executed.

You can also use a finally block to specify code that will always be executed, whether an exception is raised or not. For example:

<pre>
try:
    # code that may raise an exception
except ExceptionType:
    # code to handle the exception
finally:
    # code that will always be executed
</pre>

In this example, the code in the finally block will be executed whether an exception is raised or not. This can be useful for cleaning up resources or closing files, for example.

You can also raise your own exceptions using the raise statement. For example:

<pre>
if x &lt; 0:
    raise ValueError("x cannot be negative")
</pre>

In this example, if x is negative, a ValueError exception will be raised with the message "x cannot be negative".

<hr>

### Module in Python
In Python, a module is a file containing Python code that defines variables, functions, and classes that can be used in other Python programs. A module can be thought of as a library of code that can be reused in multiple programs.

To use a module in your Python program, you first need to import it. You can import a module using the import statement followed by the name of the module. For example, to import the math module, you would use the following statement:

<pre>
import math
</pre>

Once you have imported the module, you can use its functions and variables in your program by referencing them with the module name. For example, to use the sqrt function from the math module to calculate the square root of a number, you would use the following code:

<pre>
import math

x = 16
y = math.sqrt(x)
print(y)
</pre>

This code will output 4.0, since the square root of 16 is 4.

You can also import specific functions or variables from a module using the from keyword. For example, to import only the sqrt function from the math module, you would use the following statement:

<pre>
from math import sqrt
</pre>

This allows you to use the sqrt function directly in your code without having to reference the math module:

<pre>
from math import sqrt

x = 16
y = sqrt(x)
print(y)
</pre>

This code will output 4.0, just like the previous example.

Python comes with a number of built-in modules that provide useful functionality, such as os (for operating system functions), random (for generating random numbers), and datetime (for working with dates and times). You can also create your own modules by defining functions and variables in a Python file and then importing that file as a module in other programs.

<hr>

### Math Module in Python
The math module in Python provides various mathematical functions for performing mathematical operations in Python. Here are some of the commonly used functions from the math module:

* **math.ceil(x):** Returns the smallest integer greater than or equal to x.
* **math.floor(x):** Returns the largest integer less than or equal to x.
* **math.sqrt(x):** Returns the square root of x.
* **math.pow(x, y):** Returns x raised to the power of y.
* **math.exp(x):** Returns the exponential value of x.
* **math.log(x):** Returns the natural logarithm of x.
* **math.log10(x):** Returns the base-10 logarithm of x.
* **math.radia**ns(x):** Converts x from degrees to radians.
* **math.degr**ees(x):** Converts x from radians to degrees.
* **math.sin(x):** Returns the sine of x.
* **math.cos(x):** Returns the cosine of x.
* **math.tan(x):** Returns the tangent of x.
* **math.asin(x):** Returns the inverse sine of x.
* **math.acos(x):** Returns the inverse cosine of x.
* **math.atan(x):** Returns the inverse tangent of x.
* **math.pi:** Returns the value of pi (3.141592653589793).
* **math.e:** Returns the value of e (2.718281828459045).

To use these functions, you need to import the math module at the beginning of your program using the following code:

<pre>
import math
</pre>

Once you have imported the math module, you can call any of its functions using the dot notation, like this:

<pre>
import math

x = 10
y = 2

print(math.ceil(x/y))  # Output: 5
print(math.sqrt(x))  # Output: 3.1622776601683795
print(math.sin(math.radians(90)))  # Output: 1.0
</pre>

These are just a few examples of the many functions available in the math module. You can refer to the official Python documentation for more information on the math module and its functions.

<hr>

### Inbuilt Collections in Python
Python comes with several built-in collections that are commonly used in programming. Here are some of the most commonly used inbuilt collections:

* **Lists:** Lists are ordered collections of items that can be of different data types. Lists are mutable, meaning they can be modified after creation. You can create a list in Python by enclosing a comma-separated sequence of elements in square brackets.

<pre>
my_list = [1, 2, 3, 'four', 'five']
</pre>

* **Tuples:** Tuples are similar to lists, but they are immutable, meaning that they cannot be modified after creation. Tuples are commonly used to group related values together. You can create a tuple in Python by enclosing a comma-separated sequence of elements in parentheses.

<pre>
my_tuple = (1, 2, 3, 'four', 'five')
</pre>

* **Sets:** Sets are unordered collections of unique items. Sets are useful for removing duplicates from a list and performing set operations like union, intersection, and difference. You can create a set in Python by enclosing a comma-separated sequence of elements in curly braces, or by using the set() function.

<pre>
my_set = {1, 2, 3, 4, 5}
</pre>

* **Frozen Set:** In Python, a frozen set is an immutable version of a set. Once a frozen set is created, its elements cannot be added, removed, or modified.

<pre>
my_frozen_set = frozenset([1, 2, 3, 4, 5])
</pre>

* **Dictionaries:** Dictionaries are unordered collections of key-value pairs. Dictionaries are useful for storing and retrieving data based on a key. You can create a dictionary in Python by enclosing a comma-separated sequence of key-value pairs in curly braces, or by using the dict() function.

<pre>
my_dict = {'name': 'John', 'age': 30, 'gender': 'male'}
</pre>

* **Strings:** Strings are collections of characters. Strings are immutable, meaning they cannot be modified after creation. You can create a string in Python by enclosing a sequence of characters in single or double quotes.

<pre>
my_string = 'Hello, World!'
</pre>

These are just a few of the most commonly used inbuilt collections in Python. There are many other collections provided by the Python standard library and third-party packages that you can use in your programs.

<hr>

### String in Python
In Python, a string is a sequence of characters. It is one of the basic data types used in Python programming. Strings are defined using single quotes ('...') or double quotes ("..."). For example:

<pre>
my_string = "Hello, World!"
</pre>

This creates a string named my_string with the value "Hello, World!".

Strings can be concatenated (combined) using the + operator. For example:

<pre>
greeting = "Hello"
name = "Alice"
message = greeting + ", " + name + "!"
print(message)  # prints "Hello, Alice!"
</pre>

Strings can be indexed and sliced to access individual characters or substrings. Indexing starts from 0, and negative indexing is allowed, which starts from the end of the string (-1). Slicing is done using the colon operator :. For example:

<pre>
my_string = "Hello, World!"
print(my_string[0])     # prints "H"
print(my_string[-1])    # prints "!"
print(my_string[7:12])  # prints "World"
</pre>

Strings are immutable, which means you cannot modify a string once it has been created. However, you can create a new string by slicing and concatenating parts of the original string. For example:

<pre>
my_string = "Hello, World!"
new_string = my_string[:5] + "Python!"
print(new_string)  # prints "HelloPython!"
</pre>

Strings also support various methods for manipulating and formatting them. For example:

<pre>
my_string = "   Hello, World!   "
print(my_string.strip())  # removes whitespace from both ends of the string

my_string = "Hello, World!"
print(my_string.lower())  # converts the string to lowercase
print(my_string.upper())  # converts the string to uppercase

my_string = "Hello, {name}!"
print(my_string.format(name="Alice"))  # prints "Hello, Alice!"
</pre>

These are just a few examples of the many operations that can be performed on strings in Python.

<hr>

### List in Python
In Python, a list is a collection of items (values or objects) which are ordered and mutable. It is one of the most commonly used data structures in Python programming. A list can contain items of different data types such as integers, floats, strings, and even other lists.

Lists are defined using square brackets [] and commas to separate the items. For example:

<pre>
my_list = [1, 2, 3, 4, 5]
This creates a list named my_list with five integer items.
</pre>

You can access individual items in a list by their index (position) in the list, starting from 0. For example:

<pre>
my_list = [1, 2, 3, 4, 5]
print(my_list[0])  # prints 1
print(my_list[2])  # prints 3
</pre>

Lists are mutable, which means you can change, add or remove items after the list has been created. You can modify an item in a list by assigning a new value to it:

<pre>
my_list = [1, 2, 3, 4, 5]
my_list[2] = 10
print(my_list)  # prints [1, 2, 10, 4, 5]
</pre>

You can add items to a list using the append() method or the insert() method. For example:

<pre>
my_list = [1, 2, 3, 4, 5]
my_list.append(6)
print(my_list)  # prints [1, 2, 3, 4, 5, 6]

my_list.insert(2, 10)
print(my_list)  # prints [1, 2, 10, 3, 4, 5, 6]
</pre>

You can remove items from a list using the remove() method or the pop() method. For example:

<pre>
my_list = [1, 2, 3, 4, 5]
my_list.remove(3)
print(my_list)  # prints [1, 2, 4, 5]

popped_item = my_list.pop()
print(my_list)      # prints [1, 2, 4]
print(popped_item)  # prints 5
</pre>

Lists can also be sliced to create new lists with a subset of the original items. For example:

<pre>
my_list = [1, 2, 3, 4, 5]
new_list = my_list[1:4]
print(new_list)  # prints [2, 3, 4]
</pre>

Lists can also be nested, which means you can have lists within lists. For example:

<pre>
my_list = [1, [2, 3], 4, [5, 6, 7]]
print(my_list[1][0])  # prints 2
</pre>

<hr>

### Tuple in Python
In Python, a tuple is a collection of items (values or objects) which are ordered and immutable. It is similar to a list, but unlike a list, a tuple cannot be modified once it has been created. Tuples are defined using parentheses () and commas to separate the items. For example:

<pre>
my_tuple = (1, 2, 3, 4, 5)
</pre>

This creates a tuple named my_tuple with five integer items.

You can access individual items in a tuple by their index (position) in the tuple, starting from 0. For example:

<pre>
my_tuple = (1, 2, 3, 4, 5)
print(my_tuple[0])  # prints 1
print(my_tuple[2])  # prints 3
</pre>

Since tuples are immutable, you cannot modify an item in a tuple once it has been created. However, you can create a new tuple by concatenating two or more tuples using the + operator. For example:

<pre>
my_tuple = (1, 2, 3)
new_tuple = my_tuple + (4, 5)
print(new_tuple)  # prints (1, 2, 3, 4, 5)
</pre>

You can also create a new tuple by slicing a subset of the original items. For example:

<pre>
my_tuple = (1, 2, 3, 4, 5)
new_tuple = my_tuple[1:4]
print(new_tuple)  # prints (2, 3, 4)
</pre>

Tuples can be used as keys in dictionaries, while lists cannot. This is because dictionaries require keys to be immutable.

Tuples can be used to return multiple values from a function, which can be accessed using tuple unpacking. For example:

<pre>
def get_name_and_age():
    name = "John"
    age = 30
    return name, age

name, age = get_name_and_age()
print(name)  # prints "John"
print(age)   # prints 30
</pre>

In this example, the function get_name_and_age() returns a tuple of two values: name and age. The tuple is then unpacked into two variables name and age using tuple unpacking.

<hr>

### Dictionary in Python
A dictionary in Python is a collection of key-value pairs. Dictionaries are unordered and mutable, meaning that you can add, delete, and modify items in a dictionary after it has been created.

You can create a dictionary in Python by enclosing a comma-separated sequence of key-value pairs in curly braces {}, like this:

<pre>
my_dict = {'name': 'John', 'age': 30, 'gender': 'male'}
</pre>

In the above example, the keys are 'name', 'age', and 'gender', and their corresponding values are 'John', 30, and 'male'.

You can access the values in a dictionary by referencing the keys, like this:

<pre>
name = my_dict['name']
age = my_dict['age']
gender = my_dict['gender']
</pre>

You can also use the get() method to retrieve the value associated with a key:

<pre>
name = my_dict.get('name')
age = my_dict.get('age')
gender = my_dict.get('gender')
</pre>

The get() method returns None if the key is not found in the dictionary, or a default value that you can specify as a second argument to the method.

You can add a new key-value pair to a dictionary like this:

<pre>
my_dict['email'] = 'john@example.com'
</pre>

And you can delete a key-value pair from a dictionary like this:

<pre>
del my_dict['gender']
</pre>

You can also update the value associated with a key in a dictionary like this:

<pre>
my_dict['age'] = 35
</pre>

Dictionaries are a useful data structure in Python because they allow you to associate values with keys, which can make your code more readable and easier to understand.

<hr>

### Set in Python
In Python, a set is an unordered collection of unique elements. Sets are mutable, which means you can add or remove elements from them after they have been created.

You can create a set in Python by enclosing a comma-separated sequence of values in curly braces {}, like this:

<pre>
my_set = {1, 2, 3, 4, 5}
</pre>

In the above example, my_set is a set containing the integers 1 through 5.

You can also create a set from a list using the set() function:

<pre>
my_list = [1, 2, 2, 3, 3, 4, 5]
my_set = set(my_list)
</pre>

In this case, the duplicates are removed from the list my_list and a set containing the unique elements is created.

You can add an element to a set using the add() method:

<pre>
my_set.add(6)
</pre>

And you can remove an element from a set using the remove() method:

<pre>
my_set.remove(3)
</pre>

You can also perform various set operations on sets, such as union, intersection, and difference. Here are some examples:

<pre>
set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}

# Union of set1 and set2
print(set1 | set2)  # Output: {1, 2, 3, 4, 5, 6, 7, 8}

# Intersection of set1 and set2
print(set1 & set2)  # Output: {4, 5}

# Difference of set1 and set2
print(set1 - set2)  # Output: {1, 2, 3}

# Symmetric difference of set1 and set2
print(set1 ^ set2)  # Output: {1, 2, 3, 6, 7, 8}
</pre>

In the above examples, | represents the union operator, & represents the intersection operator, - represents the difference operator, and ^ represents the symmetric difference operator.

Sets are a useful data structure in Python for storing unique elements and performing set operations.

<hr>

### Frozen Set in Python
In Python, a frozen set is an immutable version of a set. Once a frozen set is created, its elements cannot be added, removed, or modified.

You can create a frozen set in Python by enclosing a comma-separated sequence of values in the frozenset() function, like this:

<pre>
my_frozen_set = frozenset([1, 2, 3, 4, 5])
</pre>

In the above example, my_frozen_set is a frozen set containing the integers 1 through 5.

You can perform various set operations on frozen sets, such as union, intersection, and difference. Here are some examples:

<pre>
frozen_set1 = frozenset([1, 2, 3, 4, 5])
frozen_set2 = frozenset([4, 5, 6, 7, 8])

# Union of frozen_set1 and frozen_set2
print(frozen_set1 | frozen_set2)  # Output: frozenset({1, 2, 3, 4, 5, 6, 7, 8})

# Intersection of frozen_set1 and frozen_set2
print(frozen_set1 & frozen_set2)  # Output: frozenset({4, 5})

# Difference of frozen_set1 and frozen_set2
print(frozen_set1 - frozen_set2)  # Output: frozenset({1, 2, 3})

# Symmetric difference of frozen_set1 and frozen_set2
print(frozen_set1 ^ frozen_set2)  # Output: frozenset({1, 2, 3, 6, 7, 8})
</pre>

In the above examples, | represents the union operator, & represents the intersection operator, - represents the difference operator, and ^ represents the symmetric difference operator.

Frozen sets are useful in situations where you need a set that cannot be modified, such as when you want to use a set as a key in a dictionary or as an element in another set.

<hr>

